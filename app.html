<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image processing application</title>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@300;500&display=swap');

        /* General ------------------------------------------------------- */

        * {
            box-sizing: border-box;
            padding: 0;
            margin: 0;
        }

        body {
            font-size: 14px;
            font-family: 'Quicksand';
            font-weight: 500;
        }

        input[type="file"] {
            display: none;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            padding: 5px;
        }

        button {
            font-family: 'Quicksand';
            background-color: white;
            border: 0;
            outline: 0;
        }

        /* Header -------------------------------------------------------- */

        header {
            position: relative;
        }

        header .logo .line {
            background-color: #303030;
            width: 96%;
            left: 2%;
            z-index: -1;
            height: 2px;
            position: absolute;
            top: 50%;
        }

        header .logo h1 {
            width: 90%;
            margin: 0 auto;
            padding: 15px 15px 20px 15px;

            color: #f5f5f5;
            border: 20px solid #FFFFFF;
            background-color: #303030;

            font-weight: 100;
            font-size: 1.5em;
            text-align: center;
        }

        /* Main -------------------------------------------------------- */

        /* Breadcrumbs */

        .breadcrumbs {
            display: flex;
            justify-content: center;
            letter-spacing: .05em;
            color: #bcbcbc;
            margin: 50px 0 10px 0;
        }

        .breadcrumbs>.breadcrumb {
            display: flex;
            position: relative;
        }

        .breadcrumbs>.breadcrumb>.breadcrumb-title {
            padding: 8px 10px;
            background: #FFFFFF;
        }

        .breadcrumbs>.active-breadcrumb {
            color: #404040;
        }

        .breadcrumbs>.breadcrumb>.line {
            width: 20px;
            height: .1em;
            position: relative;
            background-color: #c4c4c4;
            top: 50%;
        }

        .breadcrumbs>.active-breadcrumb>.line {
            background: #404040;
        }

        .current {
            font-weight: 600;
        }


        /* Control panel */

        .wrapper {
            width: 80%;
            margin: 3em auto;
            display: flex;
            justify-content: center;
        }

        .control-panel {
            flex: 3;
            position: relative;
            border: .15em solid #E4E4E4;
            height: 40em;
        }

        .control-panel>.control-panel-title {
            display: block;
            padding: 1em;
            text-align: center;
            border-bottom: 2px solid #E4E4E4;
            font-size: 1.1em;
        }

        .control-panel>.control-panel-body {
            padding: 1em .5em 5em .5em;
            display: flex;
            justify-content: center;
            border-radius: 5px;
        }

        .help {
            position: relative;
        }

        .help>.help-button {
            font-size: 1em;
            padding: .15em .55em;
            border: 2px solid #404040;
            border-radius: 50%;
            right: -1em;
            position: absolute;
            background: #404040;
            color: #e4e4e4;
            top: -1em;
        }

        .help>.help-button:hover {
            background-color: #404040;
            color: #f5f5f5;
        }

        .help>.help-button:hover~.help-tooltip {
            display: block;
        }

        .help>.help-tooltip {
            text-align: center;
            display: none;
            position: absolute;
            right: .6em;
            top: .6em;
            width: 80%;
            z-index: 1;
            padding: 25px;
            background: white;
            border: 2px solid #404040;
            border-radius: 5px;
        }

        .panel-button {
            width: 10em;
            height: 3em;
            text-align: center;
            padding: .7em 0;
            border-radius: 2px;
            cursor: pointer;
            border: .15em solid #404040;
        }

        .centered-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .panel-button:hover {
            background-color: #404040;
            color: #bcbcbc;
        }

        .methods-list {
            list-style: none;
            font-size: 1.1em;
            height: 22em;
            padding: 0 2em;
            text-align: left;
            overflow: overlay;
            margin-top: 2em;
        }

        .methods-list::-webkit-scrollbar {
            width: 8px;
        }

        /* Track */
        .methods-list::-webkit-scrollbar-track {
            background: #e4e4e4;
            border-radius: 2em;
        }

        /* Handle */
        .methods-list::-webkit-scrollbar-thumb {
            background: #404040;
            border-radius: 2em;
        }

        /* Handle on hover */
        .methods-list::-webkit-scrollbar-thumb:hover {
            background: #404040;
        }

        .methods-list>li {
            padding: .6em 1.4em;
            margin: .3em 0;
            cursor: pointer;
            border-left: 2px solid transparent;
        }

        .methods-list>li:hover {
            border-left: 2px solid #404040;
        }

        .methods-list>li.active-method {
            font-weight: 600;
            border-left: 2px solid #404040;
        }

        .method-title {
            font-size: 1.1em;
            font-weight: 600;
            text-align: center;
            display: block;
            padding: .7em 0;
        }

        .slider-container {
            display: flex;
            flex-flow: column nowrap;
            padding: .5em;
            width: 90%;
        }

        .slider-container .panel-button {
            margin: 1em auto;
        }

        .slider-container .range-wrapper {
            display: flex;
            justify-content: space-between;
        }

        .slider-container .slider-value-wrapper {
            display: flex;
            flex-flow: row nowrap;
        }

        .slider-value-wrapper label {
            font-size: 1.1em;
            padding: .4em 0;
            color: #6f6f6f;
        }

        .slider-value {
            width: 4em;
            margin: .4em auto;
            text-align: center;
            padding: .2em .2em .1em .2em;
        }

        .slider-settings {
            display: flex;
            flex-flow: column nowrap;
            margin: .8em;
            padding: 1.6em 0 1.4em 0;
            border-top: 2px solid #e4e4e4;
            border-bottom: 2px solid #e4e4e4;
        }

        .slider-container .slider-apply-wrapper {
            width: 100%;
            text-align: center;
        }

        .control-buttons {
            position: absolute;
            width: 100%;
            font-size: 1.1em;
            padding: .9em;
            user-select: none;
            display: flex;
            justify-content: space-between;

            left: 0;
            bottom: 0;
        }

        .control-buttons>* {
            padding: .3em;
            color: #8f8f8f;
            user-select: none;
        }

        .activate {
            border-bottom: .15em solid #404040;
            color: #404040;
            cursor: pointer;
        }



        /* Image box */

        .image-box {
            flex: 5;
            position: relative;
            margin-left: 4em;
            min-height: 400px;
            text-align: center;
        }

        .image-box canvas {
            max-width: 100%;
            left: 0;
            top: 0;
        }

        .image {
            display: inline-block;
            max-width: 500px;
        }

        .image-meta-data {
            padding: .5em;
            text-decoration: underline;
        }
    </style>
</head>

<body>

    <!---------------- Header -------------------->
    <header>
        <div class="logo">
            <div class="line"></div>
            <h1>X-ray Processing Tool</h1>
        </div>
    </header>


    <!---------------- Main ---------------------->
    <main>

        <div class="breadcrumbs">
            <div class="breadcrumb active-breadcrumb current">
                <span class="breadcrumb-title">Upload</span>
            </div>
            <div class="breadcrumb">
                <div class="line"></div>
                <span class="breadcrumb-title">Choose method</span>
            </div>
            <div class="breadcrumb">
                <div class="line"></div>
                <span class="breadcrumb-title">Customize</span>
            </div>
            <div class="breadcrumb">
                <div class="line"></div>
                <span class="breadcrumb-title">Finish</span>
            </div>
        </div>
        </div>

        <div class="wrapper">

            <div class="control-panel">
                <div class="help">
                    <span class="help-button">?</span>
                    <div class="help-tooltip"></div>
                </div>
                <span class="control-panel-title">Control Panel</span>
                <div class="control-panel-body">

                </div>
                <div class="control-buttons">
                    <button class="back-button">go back</button>
                    <button class="next-button">save & proceed</button>
                </div>
            </div>


            <div class="image-box">
                <div class="image">
                    <canvas></canvas>
                </div>
                <div class="image-meta-data"></div>
            </div>

        </div>

    </main>


    <!---------------- Footer -------------------->
    <footer></footer>
</body>
<script>
    "use strict";

    const main = (global) => {
        const controlButtons = {
            back: document.querySelector('.back-button'),
            next: document.querySelector('.next-button')
        };

        const app = new Application(
            StageHandler.build(),
            Router.build(controlButtons)
        );

        controlButtons.next.addEventListener('click', () => {
            app.proceed();
        });

        controlButtons.back.addEventListener('click', () => {
            app.goBack();
        });

        app.run();
    };

    /**
     * Core of the application, is responsible for few tasks.
     * 
     * The first is retrieving list of actions out of Stage instance,
     * getting needed controllers from the router and 
     * calling methods which were specified in the actions list.
     * 
     * Another task is to switch application's phases by using StageHandler.
     */
    class Application {
        /**
         * @param {StageHandler} stageHandler 
         * @param {Router} router 
         */
        constructor(stageHandler, router) {
            this._stageHandler = stageHandler;
            this._router = router;
        }

        run() {
            this._bootstrapStage();
        }

        /**
         * 
         * @param {boolean} bootstrap 
         */
        _bootstrapStage() {
            this._stageHandler.getActiveStage().bootstrap(this._router);
        }

        _terminateStage() {
            this._stageHandler.getActiveStage().terminate(this._router);
        }

        proceed() {
            const panelController = this._router.getController('PanelController');
            const breadcrumbController = this._router.getController('BreadcrumbController');

            const buttonState = panelController.retrieveButtonState('next');

            if (buttonState.active && this._stageHandler.nextStageExists()) {
                this._stageHandler.switchToNextStage();
                this._bootstrapStage();

                panelController.changeButtonState('next', {
                    active: this._stageHandler.getActiveStage().done
                });

                panelController.changeButtonState('back', {
                    active: true
                });

                breadcrumbController.movePointerForward();
            }
        }

        goBack() {
            const panelController = this._router.getController('PanelController');
            const breadcrumbController = this._router.getController('BreadcrumbController');

            const buttonState = panelController.retrieveButtonState('back');

            if (buttonState.active && this._stageHandler.previousStageExists()) {

                if (buttonState.skip > 0) {
                    buttonState.skip--;

                    this._terminateStage();
                    this._stageHandler.switchToPreviousStage();
                    this.goBack();
                    breadcrumbController.movePointerBack();
                    return;
                }

                this._terminateStage();
                this._stageHandler.switchToPreviousStage();
                this._bootstrapStage();

                panelController.changeButtonState('back', {
                    active: this._stageHandler.previousStageExists()
                });

                panelController.changeButtonState('next', {
                    active: this._stageHandler.getActiveStage().done
                });

                breadcrumbController.movePointerBack();
            }
        }
    }

    /**
     * Holds and controls Stage instances
     */
    class StageHandler {
        /**
         * @param {Stage[]} stages 
         */
        constructor(stages) {
            this._stages = stages;
            this._currentStage = 0;
        }

        /**
         * Builds StageHandler
         * 
         * @returns {StageHandler} instance
         */
        static build() {
            const supportedMethods = [{
                text: 'Adjust brightess',
                name: 'adjustBrightness',
                registrator: [
                    'ImageController',
                    'adjustBrightnessBootstrap'
                ]
            }, {
                text: 'Adjust contrast',
                name: 'adjustContrast',
                registrator: [
                    'ImageController',
                    'adjustContrastBootstrap'
                ]
            }, {
                text: 'Improve sharpness',
                name: 'sharpenImage',
                registrator: [
                    'ImageController',
                    'sharpenImageBootstrap'
                ]
            }, {
                text: 'Gamma correction',
                name: 'gammaCorrection',
                registrator: [
                    'ImageController',
                    'gammaCorrectionBootsrap'
                ]
            }, {
                text: 'Image negatives',
                name: 'imageNegatives',
                registrator: [
                    'ImageController',
                    'imageNegativesBootsrap'
                ]
            }, {
                text: 'Log transform',
                name: 'logTransform',
                registrator: [
                    'ImageController',
                    'logTransformBootsrap'
                ]
            }, {
                text: 'Edge detection (Canny)',
                name: 'cannyEdgeDetection',
                registrator: [
                    'ImageController',
                    'cannyEdgeDetectionBootstrap'
                ]
            }, {
                text: 'Image smoothing',
                name: 'imageSmoothing',
                registrator: [
                    'ImageController',
                    'imageSmoothingBootstrap'
                ]
            }, {
                text: 'Adaptive threshold',
                name: 'adaptiveThreshold',
                registrator: [
                    'ImageController',
                    'adaptiveThresholdBootstrap'
                ]
            }];

            return new this([
                new FileUploadStage({
                    bootstrap: [
                        ['ImageController', 'switchToFileUploadStage'],
                        ['PanelController', 'switchToFileUploadStage']
                    ]
                }),
                new MethodSelectionStage({
                    bootstrap: [
                        ['ImageController', 'switchToMethodChoosigStage'],
                        ['PanelController', 'switchToMethodChoosigStage']
                    ]
                }, supportedMethods),
                new MethodCustomizationStage({
                    bootstrap: [
                        ['PanelController', 'switchToCustomizationStage']
                    ],
                    terminate: [
                        ['ImageController', 'terminateCustomizationStage']
                    ]
                }, supportedMethods),
                new FinishStage({
                    bootstrap: [
                        ['PanelController', 'switchToFinishStage'],
                        ['ImageController', 'switchToFinishStage']
                    ],
                    terminate: [
                        ['PanelController', 'terminateFinishStage']
                    ]
                }),
            ]);
        }

        /**
         * @returns {Stage} instance
         */
        getActiveStage() {
            return this._stages[this._currentStage];
        }

        /**
         * @returns {Stage} instance
         */
        nextStageIsDone() {
            if (this.nextStageExists()) {
                return this._stages[this._currentStage + 1].getState['done'];
            }

            return false;
        }

        switchToNextStage() {
            this._currentStage++
        }

        switchToPreviousStage() {
            this._currentStage--;
        }

        /**
         * @returns {boolean}
         */
        nextStageExists() {
            return this._stages.length > this._currentStage + 1;
        }

        /**
         * @returns {boolean}
         */
        previousStageExists() {
            return this._currentStage > 0;
        }
    }

    /**
     * Stage is responsible for holding actions to bootstrap and terminate the application's phase.
     * 
     * The actions call controller methods to register event handlers,
     * render some content, change state of the application.
     */
    class Stage {
        /**
         * @param {array} bootstrap list of actions to be called when stage is bootstraped
         * @param {array} terminate list of actions to be called when stage is terminating
        */
        constructor({ bootstrap, terminate = [] }) {
            this._actions = {
                bootstrap: bootstrap,
                terminate: terminate
            };

            this._state = null;
            this._components = null;
            this._done = false;
        }

        /**
         * Bootstraps stage.
         * 
         * @param {Router} router instance
         */
        bootstrap(router) {
            for (const [controller, action] of this.getActions('bootstrap')) {
                router.getController(controller)[action](
                    this,
                    router
                );
            }
        }

        /**
         * Terminates stage.
         * 
         * @abstract
         * @param {Router} router instance
         */
        terminate(router) {
            this._state = null;
            this._done = false;
            this._components = null;
            for (const [controller, action] of this.getActions('terminate')) {
                router.getController(controller)[action](
                    this,
                    router
                );
            }
        }

        /**
         * Returns collection of DOM elements specific to a stage
         * 
         * @abstract
         * @returns {object}
         */
        _build() { }

        /**
         * @returns {object} Collection of DOM components
         */
        getDomComponents() {
            if (this._components !== null) {
                return this._components;
            }

            this._components = this._build();
            return this._components;
        }

        /**
         * @param {string} mode can be bootstrap or termination
         * @returns {array} 
         */
        getActions = mode => this._actions[mode];

        /**
         * @returns {boolean}
         */
        get state() { return this._state };

        /**
         * @param {object} state
         */
        set state(state) { this._state = state };

        /**
         * @returns {boolean}
         */
        get done() { return this._done };

        /**
         * @param {boolean} status
         */
        set done(status) { this._done = status };
    }

    /**
     * @inheritdoc
     */
    class MethodSelectionStage extends Stage {
        /**
         * @inheritdoc
         * @param {object} supportedMethods supported methods of image processing 
         */
        constructor(actions, supportedMethods) {
            super(actions);
            this._supportedMethods = supportedMethods;
        }

        _build() {
            const tooltip = document.createElement('p');
            tooltip.textContent = 'Select a method of how to alter the image';

            const list = document.createElement('ul');
            list.classList = 'methods-list';

            const methodsContext = Symbol.for('methodContext');

            for (const methodContext of this._supportedMethods) {
                const li = document.createElement('li');
                li.textContent = methodContext.text;
                li[methodsContext] = methodContext;
                list.append(li);
            }

            return {
                methodsList: list,
                tooltip: tooltip
            };
        }
    }

    /**
     * @inheritdoc
     */
    class FileUploadStage extends Stage {
        /**
         * @inheritdoc
        */
        constructor(actions) {
            super(actions);
        }

        /**
         * @inheritdoc
         */
        _build() {
            const tooltip = document.createElement('p');
            tooltip.textContent = 'Choose an image which needs to be altered.';

            const button = document.createElement('label');
            button.classList.add('centered-button', 'panel-button');
            button.textContent = 'Choose an image';

            const input = document.createElement('input');
            input.type = 'file';
            input.name = 'image';
            input.accept = 'image/*'
            input.classList = 'upload-input';
            button.append(input);

            return {
                button: button,
                tooltip: tooltip
            };
        }
    }

    /**
     * @inheritdoc
     */
    class FinishStage extends Stage {
        /**
         * @inheritdoc
        */
        constructor(actions) {
            super(actions);
        }

        /**
         * @inheritdoc
         */
        _build() {
            const tooltip = document.createElement('p');
            tooltip.textContent = 'Download or go back and apply another method.';

            const downloadButton = document.createElement('button');
            downloadButton.classList.add('centered-button', 'panel-button');
            downloadButton.textContent = 'Download result';

            return {
                button: downloadButton,
                tooltip: tooltip
            };
        }
    }

    /**
     * @inheritdoc
     */
    class MethodCustomizationStage extends Stage {
        /**
         * @inheritdoc
         */
        constructor(actions) {
            super(actions);
        }

        /**
         * @inheritdoc
         */
        _build() {
            return {
                controls: {
                    adjustBrightness: {
                        elements: this._buildSliders('Adjust Brightness', [{
                            min: -235,
                            labelText: "value",
                            step: 1,
                            max: 235,
                            startValue: 0
                        }]),
                        tooltip: document.createElement('p')
                            .textContent = `Select the brightness altering level by moving the slider
                            or entering it into the input box`
                    },
                    adjustContrast: {
                        elements: this._buildSliders('Adjust Contrast', [{
                            min: 0.1,
                            labelText: "level",
                            step: 0.05,
                            max: 5,
                            startValue: 1
                        }]),
                        tooltip: document.createElement('p')
                            .textContent = `Select the contrast altering level by moving the slider
                            or entering it into the input box. Values lower than 
                            1 will decrease contrast, higher than 1 increase.`
                    },
                    sharpenImage: {
                        elements: this._buildSliders('Image sharpen', [{
                            min: 0,
                            labelText: "level",
                            step: 1,
                            max: 10,
                            startValue: 1
                        }]),
                        tooltip: document.createElement('p')
                            .textContent = `Select the sharpening level by moving the slider
                             or entering it into the input box.`
                    },
                    gammaCorrection: {
                        elements: this._buildSliders('Gamma correction', [{
                            min: 0.1,
                            labelText: "level",
                            step: 0.1,
                            max: 7,
                            startValue: 1
                        }]),
                        tooltip: document.createElement('p')
                            .textContent = `Select the gamma correction level by moving the slider
                            or entering it into the input box.`
                    },
                    imageNegatives: {
                        elements: (() => {
                            const applyButton = document.createElement('button');
                            const methodTitle = document.createElement('span');
                            const wrapper = document.createElement('div');

                            applyButton.classList.add('panel-button', 'centered-button');
                            applyButton.textContent = 'apply';

                            // Method title
                            methodTitle.textContent = 'Image negatives';
                            methodTitle.classList.add('method-title');

                            wrapper.classList.add('slider-container');
                            wrapper.append(methodTitle, applyButton);

                            return wrapper;
                        })(),
                        tooltip: document.createElement('p')
                            .textContent = `Press the button to apply image inversion method.`
                    },
                    logTransform: {
                        elements: this._buildSliders('Log transform', [{
                            min: 30,
                            labelText: "level",
                            step: 1,
                            max: 100,
                            startValue: 30
                        }]),
                        tooltip: document.createElement('p')
                            .textContent = `Select the tranformation level by moving the slider
                             or entering it into the input box.`
                    },
                    cannyEdgeDetection: {
                        elements: this._buildSliders('Edge detection (Canny)', [{
                            min: 1,
                            labelText: "min tresh:",
                            step: 1,
                            max: 255,
                            startValue: 1
                        }, {
                            min: 1,
                            labelText: "max thresh: ",
                            step: 1,
                            max: 255,
                            startValue: 1
                        }]),
                        tooltip: document.createElement('p')
                            .textContent = `Adjust min and max thresholds to find best fit of the line detection.`
                    },
                    imageSmoothing: {
                        elements: this._buildSliders('Image smoothing', [{
                            min: 1,
                            labelText: "smoothing level: ",
                            step: 2,
                            max: 25,
                            startValue: 1
                        },]),
                        tooltip: document.createElement('p')
                            .textContent = `Select the smoothening level by moving the slider
                             or entering it into the input box.`
                    },
                    adaptiveThreshold: {
                        elements: this._buildSliders('Adaptive threshold', [{
                            min: 3,
                            labelText: "block size: ",
                            step: 2,
                            max: 25,
                            startValue: 1
                        }, {
                            min: 0,
                            labelText: "constant: ",
                            step: 1,
                            max: 30,
                            startValue: 1
                        }]),
                        tooltip: document.createElement('p')
                            .textContent = `Block size is used to calculate a threshold value by using pixel neighborhood.
                                The constant is subtracted from the mean or weighted mean, it will help to reduce noise`
                    }
                }
            };
        }

        _buildSliders(methodTitleText, settings) {
            const applyButton = document.createElement('button');
            const methodTitle = document.createElement('span');
            const slidersWrapper = document.createDocumentFragment()
            const sliderContainer = document.createElement('div');
            const applyButtonWrapper = document.createElement('div');

            for (let i = 0; i < settings.length; i++) {
                let slider = document.createElement('input');
                let sliderTo = document.createElement('span');
                let sliderFrom = document.createElement('span');
                let sliderValue = document.createElement('input');
                let sliderSettings = document.createElement('div');
                let sliderValueLabel = document.createElement('label');
                let sliderRangeWrapper = document.createElement('div');
                let sliderValueWrapper = document.createElement('div');

                let { min, max, startValue, step, labelText } = settings[i];

                // Slider
                slider.min = min;
                slider.max = max;
                slider.step = step;
                slider.type = 'range';
                slider.value = startValue;
                slider.userMousedown = false;
                slider.classList.add('slider');

                sliderSettings.classList.add('slider-settings');
                sliderSettings.append(slider, sliderRangeWrapper);

                // Slider range
                sliderFrom.classList.add('slider-from');
                sliderFrom.textContent = min;

                sliderTo.classList.add('slider-to');
                sliderTo.textContent = max;

                sliderRangeWrapper.classList.add('range-wrapper');
                sliderRangeWrapper.append(sliderFrom, sliderTo);

                // Slider value
                sliderValue.type = 'number';
                sliderValue.step = step;
                sliderValue.min = min;
                sliderValue.max = max;
                sliderValue.value = startValue;
                sliderValue.classList.add('slider-value');
                sliderValue.id = 'slider-value-id'

                slider.addEventListener('change', (event) => {
                    sliderValue.value = event.target.value;
                });

                sliderValue.addEventListener('change', (event) => {
                    slider.value = sliderValue.value;
                });

                slider.addEventListener('mousemove', (event) => {
                    if (slider.userMousedown) {
                        slider.dispatchEvent(new Event('change'));
                    }
                });

                slider.onmousedown = () => slider.userMousedown = true;
                slider.onmouseup = () => slider.userMousedown = false;

                sliderValueLabel.textContent = labelText;
                sliderValueLabel.htmlFor = 'slider-value-id';

                sliderValueWrapper.classList.add('slider-value-wrapper');
                sliderValueWrapper.append(sliderValueLabel, sliderValue);

                slidersWrapper.append(sliderSettings, sliderValueWrapper);
            }

            // Method title
            methodTitle.textContent = methodTitleText;
            methodTitle.classList.add('method-title');

            // Button
            applyButton.classList.add('panel-button');
            applyButton.textContent = 'apply';

            applyButtonWrapper.classList.add('slider-apply-wrapper');
            applyButtonWrapper.append(applyButton);

            // Container
            sliderContainer.classList.add('slider-container');
            sliderContainer.append(
                methodTitle, slidersWrapper, applyButtonWrapper
            );

            return sliderContainer;
        }

    }

    class NotificationManager {
        /**
         * Handles errors occurence
         * 
         * @param {Error} error instance 
         */
        static errorOccured(error) {
            this.notifyUser(error.message, 'error');
            throw error;
        }

        static notifyUser(message, type) {
            alert(message);
        }
    }

    /**
     * Router holds controllers
     */
    class Router {
        /**
         * @param {object} controllers - collection of controller instances
         */
        constructor(controllers) {
            this._controllers = controllers;
        }

        /**
         * Builds Router.
         * 
         * @param {object} controlButtons DOM elements 
         * @returns {Router} instance
         */
        static build(controlButtons) {
            return new this({
                PanelController: new PanelController(
                    new PanelService(
                        new PanelView({
                            body: document.querySelector('.control-panel-body'),
                            tooltip: document.querySelector('.help-tooltip'),
                            buttons: controlButtons
                        })
                    )
                ),
                BreadcrumbController: new BreadcrumbController(
                    new BreadcrumbService(
                        new BreadcrumbView({
                            breadcrumbs: document.querySelector('.breadcrumbs')
                        })
                    )
                ),
                ImageController: new ImageController(
                    new ImageService(
                        new ImageView({
                            canvas: document.querySelector('.image-box canvas'),
                            meta: document.querySelector('.image-meta-data')
                        })
                    )
                )
            });
        }

        /**
         * @param {string} name controller's name 
         * @returns {object} instance of a controller
         */
        getController(name) {
            if (!this._controllerExists(name)) {
                throw Error(`Controller ${name} does not exist`);
            }

            return this._controllers[name];
        }

        /**
         * 
         * @param {string} name controller's name  
         * @returns {boolean}
         */
        _controllerExists(name) {
            return name in this._controllers;
        }
    }

    class BreadcrumbController {
        /**
         * @param {BreadcrumbService} service instance 
         */
        constructor(service) {
            this._service = service;
        }

        movePointerForward() {
            this._service.movePointerForward();
        }

        movePointerBack() {
            this._service.movePointerBack();
        }
    }

    class ImageController {
        /**
         * @param {ImageService} service instance
         */
        constructor(service) {
            this._service = service;
        }

        /**
         * @param {Stage} stage instance 
         * @param {Router} router instance
         */
        switchToFileUploadStage(stage, router) {
            this._service.registerFileUploadEventHandlers(
                stage, router
            );
        }

        /**
         * @param {Stage} stage instance 
         * @param {Router} router instance
         */
        switchToMethodChoosigStage(stage, router) {
            this._service.registerMethodChoosingEventHandlers(
                stage, router
            );
        }

        /**
         * @param {Stage} stage instance 
         * @param {Router} router instance
         */
        switchToFinishStage(stage, router) {
            this._service.saveImage();
            this._service.registerDownloadHandlers(
                stage, router
            );
        }

        /**
         * @param {Stage} stage instance 
         * @param {Router} router instance
         */
        terminateCustomizationStage(stage, router) {
            this._service.redrawImage();
        }

        retrieveChosenMethodContext() {
            return this._service.getChosenMethodContext();
        }

        adjustBrightnessBootstrap(stage, router) {
            this._service.registerAdjustBrightnessHandlers(stage, router);
        }

        adjustContrastBootstrap(stage, router) {
            this._service.registerAdjustContrastHandlers(stage, router);
        }

        sharpenImageBootstrap(stage, router) {
            this._service.registerSharpenImageHandlers(stage, router);
        }

        gammaCorrectionBootsrap(stage, router) {
            this._service.registerGammaCorrectionHandlers(stage, router);
        }

        imageNegativesBootsrap(stage, router) {
            this._service.registerImageNegativesHandlers(stage, router);
        }

        logTransformBootsrap(stage, router) {
            this._service.registerLogTransformHandlers(stage, router);
        }

        cannyEdgeDetectionBootstrap(stage, router) {
            this._service.registerCannyEdgeDetectionHandlers(stage, router);
        } imageSmoothing

        imageSmoothingBootstrap(stage, router) {
            this._service.registerImageSmoothingHandlers(stage, router);
        }

        adaptiveThresholdBootstrap(stage, router) {
            this._service.registerAdaptiveThresholdHandlers(stage, router);
        }

    }

    class PanelController {
        /**
         * @param {PanelService} service instance
         */
        constructor(service) {
            this._service = service;
        }

        /**
         * @param {Stage} stage  
         */
        switchToFileUploadStage(stage) {
            this._service.renderUpdate(
                'body',
                stage.getDomComponents().button
            );

            this._service.renderUpdate(
                'tooltip',
                stage.getDomComponents().tooltip
            );
        }

        /**
         * @param {Stage} stage  
         */
        switchToMethodChoosigStage(stage) {
            this._service.renderUpdate(
                'body', stage.getDomComponents().methodsList
            );

            this._service.renderUpdate(
                'tooltip', stage.getDomComponents().tooltip
            );
        }

        /**
         * @param {Stage} stage  
         * @param {Router} router  
         */
        switchToCustomizationStage(stage, router) {
            const methodsContext = router.getController('ImageController')
                .retrieveChosenMethodContext();
            const [controller, action] = methodsContext.registrator;
            const controls = stage.getDomComponents().controls[methodsContext.name]


            this._service.renderUpdate('body', controls.elements);

            this._service.renderUpdate('tooltip', controls.tooltip);

            router.getController(controller)[action](stage, router);
        }

        /**
         * @param {Stage} stage  
         * @param {Router} router  
         */
        switchToFinishStage(stage, router) {
            this._service.renderUpdate(
                'body', stage.getDomComponents().button
            );

            this._service.renderUpdate(
                'tooltip', stage.getDomComponents().tooltip
            );

            this._service.changeButtonContent('back', 'back to methods');
            this._service.changeButtonContent('next', '');
            this._service.changeButtonState('back', {
                skip: 1
            });
        }

        terminateFinishStage(stage, router) {
            this._service.resetButtonContent('back');
            this._service.resetButtonContent('next');
        }

        /**
         * @param {string} buttonName 
         * @param {object} state 
         */
        changeButtonState(buttonName, state) {
            this._service.changeButtonState(buttonName, state);
        }


        changeButtonContent(buttonName, content) {
            this._service.changeButtonState(buttonName, content)
        }

        /**
         * @param {string} buttonName
         */
        retrieveButtonState(buttonName) {
            return this._service.retrieveButtonState(buttonName);
        }
    }

    class BreadcrumbService {
        /**
         * @param {Breadcrumb} view instace 
         */
        constructor(view) {
            this._view = view;
            this._currentBreadcrumb = 0;
            this._breadcrumbsAmount = view.getBreadcrumbsAmount();
        }

        movePointerForward() {
            if (this._currentBreadcrumb + 1 < this._view.getBreadcrumbsAmount()) {
                this._view.movePointerForward(++this._currentBreadcrumb);
            }
        }

        movePointerBack() {
            if (this._currentBreadcrumb > 0) {
                this._view.movePointerBack(--this._currentBreadcrumb);
            }
        }
    }

    class ImageService {
        /**
         * @param {ImageView} view instance  
         */
        constructor(view) {
            this._view = view;
            this._chosenMethodContext = null;
        }

        /**
         * @param {object} domComponents collection of DOM elements
         */
        registerFileUploadEventHandlers(stage, router) {
            stage.getDomComponents().button.control.addEventListener('change', (event) => {
                if (!this._isImage(event.target.files[0])) {
                    NotificationManager.errorOccured(
                        new Error("Uploaded file must be an image")
                    );

                    return false;
                }

                this._view.imageBlob = event.target.files[0];
                this._view.imageName = event.target.files[0].name;

                this.setupImageBox();

                stage.state = { imageBlob: event.target.files[0] };
                stage.done = true;

                router.getController('PanelController').changeButtonState(
                    'next',
                    { active: true }
                );
            });
        }

        /**
         * @param {Stage} stage instance
         * @param {Router} router instance
         */
        registerMethodChoosingEventHandlers(stage, router) {
            stage.getDomComponents().methodsList.addEventListener('click', (event) => {
                if (event.target.tagName !== 'LI') {
                    return false;
                }
                const li = event.target;
                const activeLi = li.parentElement.querySelector('.active-method');

                this._chosenMethodContext = li[Symbol.for('methodContext')];

                if (activeLi !== null) {
                    activeLi.classList.remove('active-method');
                }

                li.classList.add('active-method');
                stage.done = true;

                router.getController('PanelController').changeButtonState(
                    'next', { active: true }
                );
            });
        }

        /**
         * @param {Stage} stage instance
         * @param {Router} router instance
         */
        registerAdjustBrightnessHandlers(stage, router) {
            this._slidersApplyButtonRegistration(stage, router, this._view.alterBrightness);
        }

        /**
         * @param {Stage} stage instance
         * @param {Router} router instance
         */
        registerAdjustContrastHandlers(stage, router) {
            this._slidersApplyButtonRegistration(stage, router, this._view.alterContrast);
        }

        /**
         * @param {Stage} stage instance
         * @param {Router} router instance
         */
        registerSharpenImageHandlers(stage, router) {
            this._slidersApplyButtonRegistration(stage, router, this._view.sharpenImage);
        }

        /**
         * @param {Stage} stage instance
         */
        registerGammaCorrectionHandlers(stage, router) {
            this._slidersApplyButtonRegistration(stage, router, this._view.correctGamma);
        }

        registerImageNegativesHandlers(stage, router) {
            const panelController = router.getController('PanelController');
            const applyButton = stage.getDomComponents()
                .controls[this._chosenMethodContext.name].elements.querySelector('button');

            applyButton.addEventListener('click', () => {
                this._view.imageNegatives();
                panelController.changeButtonState('next', { active: true });
                stage.done = true;
            });
        }

        registerLogTransformHandlers(stage, router) {
            this._slidersApplyButtonRegistration(stage, router, this._view.logTransform);
        }

        registerCannyEdgeDetectionHandlers(stage, router) {
            this._slidersApplyButtonRegistration(stage, router, this._view.detectEdgeCanny);
        }

        registerImageSmoothingHandlers(stage, router) {
            this._slidersApplyButtonRegistration(stage, router, this._view.smoothenImage);
        }

        registerAdaptiveThresholdHandlers(stage, router) {
            this._slidersApplyButtonRegistration(stage, router, this._view.adaptThreshold);
        }

        registerDownloadHandlers(stage, router) {
            stage.getDomComponents().button.addEventListener('click', async () => {
                const url = this._view.generateImageURL();
                const link = document.createElement('a');
                link.href = url;
                link.download = this._view.imageName;
                link.click();
            });
        }

        _slidersApplyButtonRegistration(stage, router, callback) {
            const panelController = router.getController('PanelController');

            const container = stage.getDomComponents()
                .controls[this._chosenMethodContext.name].elements;
            const button = container.querySelector('button');
            const inputs = container.querySelectorAll('.slider-value');
            const sliders = container.querySelectorAll('.slider');
            const limitValues = [];



            for (const slider of sliders) {
                limitValues.push({ min: slider.min, max: slider.max });
            }

            button.addEventListener('click', (event) => {
                let values = [];

                for (const [key, input] of Object.entries(inputs)) {
                    if (+input.value > limitValues[key].max) {
                        input.value = limitValues[key].max
                    } else if (+input.value < limitValues[key].min) {
                        input.value = limitValues[key].min
                    }

                    values.push(+input.value);
                }

                callback.apply(this._view, values);
                panelController.changeButtonState('next', { active: true });
                stage.done = true;
            });
        }

        /**
         * @param {File} imageFile instance
         */
        _isImage(imageFile) {
            if (imageFile.type.split('/')[0] !== 'image') {
                return false;
            }

            return true;
        }

        /**
         * @returns {string} 
         */
        getChosenMethodContext() {
            return this._chosenMethodContext;
        }

        redrawImage() {
            this._view.drawImage();
        }

        setupImageBox() {
            this._view.drawImage();
            this._view.updateMetaData();
        }

        saveImage() {
            this._view.saveImage();
        }
    }

    class PanelService {
        /**
         * @param {PanelView} view instance 
         */
        constructor(view) {
            this._view = view;
        }

        /**
         * @param {string} part control panel part name
         * @param {HTMLElement} content 
         */
        renderUpdate(part, content) {
            this._view.clearPanelPart(part);
            this._view.fillPanelPart(part, content);
        }

        /**
        * @param {string} buttonName 
        * @param {object} state 
        */
        changeButtonState(buttonName, state) {
            this._view.setButtonState(buttonName, state);
        }

        /**
         * @param {string} buttonName
         * @returns {object} state
         */
        retrieveButtonState(buttonName) {
            return this._view.getButtonState(buttonName);
        }

        changeButtonContent(buttonName, content) {
            this._view.changeButtonContent(buttonName, content);
        }

        resetButtonContent(buttonName) {
            this._view.changeButtonContentToDefault(buttonName);
        }
    }

    class BreadcrumbView {
        /**
         * @param {object} breadcrumbParts collection of DOM elements 
         */
        constructor(breadcrumbParts) {
            this._breadcrumbParts = breadcrumbParts;
        }

        getBreadcrumbsAmount() {
            return this._breadcrumbParts.breadcrumbs.children.length;
        }

        movePointerForward(nextBreadcrumb) {
            this._breadcrumbParts.breadcrumbs
                .children[nextBreadcrumb - 1].classList.remove('current');

            this._breadcrumbParts.breadcrumbs
                .children[nextBreadcrumb].classList.add('current', 'active-breadcrumb');
        }

        movePointerBack(previousBreadcrumb) {
            this._breadcrumbParts.breadcrumbs
                .children[previousBreadcrumb + 1]
                .classList.remove('current', 'active-breadcrumb');

            this._breadcrumbParts.breadcrumbs
                .children[previousBreadcrumb].classList.add('current');
        }

    }

    class ImageView {
        /**
         * @param {object} imageBoxParts collection of DOM elemets
         */
        constructor(imageBoxParts) {
            this._imageBoxParts = imageBoxParts;
            this._imageBlob = null
            this._imageName = null;
            this._redraw = false;
        }

        _getColorIndices(x, y, width) {
            const index = x * 4 + y * (width * 4);
            return [index, index + 1, index + 2, index + 3];
        }

        alterBrightness(value) {
            if (this._redraw) {
                this.drawImage().then(() => {
                    this._redraw = false;
                    this.alterBrightness(value);
                });
            } else {
                this._redraw = true;

                const context = this._imageBoxParts.canvas.getContext('2d');
                const imageData = context.getImageData(
                    0,
                    0,
                    this._imageBoxParts.canvas.width,
                    this._imageBoxParts.canvas.height
                );

                for (let x = 0; x < imageData.width; x++) {
                    for (let y = 0; y < imageData.height; y++) {
                        const [red, green, blue, alpha] = this._getColorIndices(
                            x, y, imageData.width
                        );

                        [
                            imageData.data[red],
                            imageData.data[green],
                            imageData.data[blue]
                        ] = [
                                imageData.data[red] + value,
                                imageData.data[green] + value,
                                imageData.data[blue] + value
                            ];
                    }
                }

                context.putImageData(imageData, 0, 0);
            }
        }

        alterContrast(value) {
            if (this._redraw) {
                this.drawImage().then(() => {
                    this._redraw = false;
                    this.alterContrast(value);
                });
            } else {
                this._redraw = true;

                const context = this._imageBoxParts.canvas.getContext('2d');
                const imageData = context.getImageData(
                    0,
                    0,
                    this._imageBoxParts.canvas.width,
                    this._imageBoxParts.canvas.height
                );

                for (let x = 0; x < imageData.width; x++) {
                    for (let y = 0; y < imageData.height; y++) {
                        const [red, green, blue, alpha] = this._getColorIndices(
                            x, y, imageData.width
                        );

                        [
                            imageData.data[red],
                            imageData.data[green],
                            imageData.data[blue]
                        ] = [
                                imageData.data[red] * value,
                                imageData.data[green] * value,
                                imageData.data[blue] * value
                            ];
                    }
                }

                context.putImageData(imageData, 0, 0);
            }
        }

        sharpenImage(amount) {
            if (this._redraw) {
                this.drawImage().then(() => {
                    this._redraw = false;
                    this.sharpenImage(amount);
                });
            } else {
                this._redraw = true;
                if (amount < 1) { return }
                const src = cv.imread(this._imageBoxParts.canvas);
                const laplasianResult = new cv.Mat(),
                    subtractionResult = new cv.Mat(),
                    mask = new cv.Mat();

                // cv.cvtColor(src, src, cv.COLOR_RGB2GRAY, 0);
                cv.Laplacian(src, laplasianResult, cv.CV_8U, 1, 1, 0, cv.BORDER_DEFAULT);

                cv.subtract(src, laplasianResult, subtractionResult, mask, -1);

                for (let i = 1; i <= amount; i++) {
                    cv.subtract(subtractionResult, laplasianResult, subtractionResult, mask, -1);
                }

                cv.imshow(this._imageBoxParts.canvas, subtractionResult);
                src.delete();
                laplasianResult.delete();
                subtractionResult.delete();
                mask.delete();
            }
        }

        correctGamma(gamma) {
            if (this._redraw) {
                this.drawImage().then(() => {
                    this._redraw = false;
                    this.correctGamma(gamma);
                });
            } else {
                this._redraw = true;
                const gammaCorrection = 1 / gamma;

                const context = this._imageBoxParts.canvas.getContext('2d');
                const imageData = context.getImageData(
                    0,
                    0,
                    this._imageBoxParts.canvas.width,
                    this._imageBoxParts.canvas.height
                );

                for (let x = 0; x < imageData.width; x++) {
                    for (let y = 0; y < imageData.height; y++) {
                        const [red, green, blue, alpha] = this._getColorIndices(
                            x, y, imageData.width
                        );

                        [
                            imageData.data[red],
                            imageData.data[green],
                            imageData.data[blue]
                        ] = [
                                255 * ((imageData.data[red] / 255) ** gammaCorrection),
                                255 * ((imageData.data[green] / 255) ** gammaCorrection),
                                255 * ((imageData.data[blue] / 255) ** gammaCorrection)
                            ];
                    }
                }

                context.putImageData(imageData, 0, 0);
            }
        }

        imageNegatives() {
            if (this._redraw) {
                this.drawImage().then(() => {
                    this._redraw = false;
                    this.imageNegatives();
                });
            } else {
                this._redraw = true;

                const context = this._imageBoxParts.canvas.getContext('2d');
                const imageData = context.getImageData(
                    0,
                    0,
                    this._imageBoxParts.canvas.width,
                    this._imageBoxParts.canvas.height
                );

                for (let x = 0; x < imageData.width; x++) {
                    for (let y = 0; y < imageData.height; y++) {
                        const [red, green, blue, alpha] = this._getColorIndices(
                            x, y, imageData.width
                        );

                        [
                            imageData.data[red],
                            imageData.data[green],
                            imageData.data[blue]
                        ] = [
                                255 - imageData.data[red],
                                255 - imageData.data[green],
                                255 - imageData.data[blue]
                            ];
                    }
                }

                context.putImageData(imageData, 0, 0);
            }
        }

        logTransform(value) {
            if (this._redraw) {
                this.drawImage().then(() => {
                    this._redraw = false;
                    this.logTransform(value);
                });
            } else {
                this._redraw = true;

                const context = this._imageBoxParts.canvas.getContext('2d');
                const imageData = context.getImageData(
                    0,
                    0,
                    this._imageBoxParts.canvas.width,
                    this._imageBoxParts.canvas.height
                );

                for (let x = 0; x < imageData.width; x++) {
                    for (let y = 0; y < imageData.height; y++) {
                        const [red, green, blue, alpha] = this._getColorIndices(
                            x, y, imageData.width
                        );

                        [
                            imageData.data[red],
                            imageData.data[green],
                            imageData.data[blue]
                        ] = [
                                value * Math.log(imageData.data[red] + 1),
                                value * Math.log(imageData.data[green] + 1),
                                value * Math.log(imageData.data[blue] + 1)
                            ];
                    }
                }

                context.putImageData(imageData, 0, 0);
            }
        }

        detectEdgeCanny(min, max) {
            if (this._redraw) {
                this.drawImage().then(() => {
                    this._redraw = false;
                    this.detectEdgeCanny(min, max);
                });
            } else {
                this._redraw = true;

                const src = cv.imread(this._imageBoxParts.canvas);
                const dst = new cv.Mat();
                cv.cvtColor(src, src, cv.COLOR_RGB2GRAY, 0);
                cv.Canny(src, dst, min, max, 3, false);
                cv.imshow(this._imageBoxParts.canvas, dst);
                src.delete(); dst.delete();
            }
        }

        smoothenImage(grid) {
            if (this._redraw) {
                this.drawImage().then(() => {
                    this._redraw = false;
                    this.smoothenImage(grid);
                });
            } else {
                this._redraw = true;

                const src = cv.imread(this._imageBoxParts.canvas);
                const dst = new cv.Mat();
                const ksize = new cv.Size(grid, grid);

                cv.GaussianBlur(src, dst, ksize, 0, 0, cv.BORDER_DEFAULT);
                cv.imshow(this._imageBoxParts.canvas, dst);
                src.delete(); dst.delete();
            }
        }

        adaptThreshold(grid, c) {
            if (this._redraw) {
                this.drawImage().then(() => {
                    this._redraw = false;
                    this.adaptThreshold(grid, c);
                });
            } else {
                this._redraw = true;

                const src = cv.imread(this._imageBoxParts.canvas);
                const dst = new cv.Mat();
                cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
                cv.adaptiveThreshold(src, dst, 250, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, grid, c);
                cv.imshow(this._imageBoxParts.canvas, dst);
                src.delete(); dst.delete();
            }
        }

        set imageBlob(blob) { this._imageBlob = blob };
        get imageBlob() { return this._imageBlob };

        set imageName(name) { this._imageName = name };
        get imageName() { return this._imageName };

        /**
         * @param {File} imageFile instance
         */
        drawImage() {
            return new Promise((resolve) => {
                const image = new Image();
                image.src = URL.createObjectURL(this._imageBlob);

                image.onload = () => {
                    const context = this._imageBoxParts.canvas.getContext("2d");

                    this._imageBoxParts.canvas.width = image.width;
                    this._imageBoxParts.canvas.height = image.height;

                    context.drawImage(image, 0, 0);
                    URL.revokeObjectURL(image.src);

                    resolve();
                };
            });
        }

        /**
         * @param {File} imageFile instance 
         */
        updateMetaData() {
            const filename = document.createElement('span');
            this._imageBoxParts.meta.innerHTML = '';
            filename.textContent = this._imageName;

            this._imageBoxParts.meta.append(filename);
        }

        saveImage() {
            this._imageBoxParts.canvas.toBlob((blob) => {
                this._imageBlob = blob;
            }, this._imageBlob.type);
        }

        generateImageURL() {
            return URL.createObjectURL(this._imageBlob);
        }
    }

    class PanelView {
        /**
         * @param {object} panelDomParts collection of HTMLElement intances
         */
        constructor(panelDomParts) {
            this._panelDomParts = panelDomParts;
            this._defaultButtonContent = {
                back: panelDomParts.buttons['back'].textContent,
                next: panelDomParts.buttons['next'].textContent
            };

            this._controlButtons = {
                back: {
                    active: false,
                    skip: 0
                },
                next: {
                    active: false,
                    skip: 0
                }
            };
        }

        /**
         * @param {string} buttonName
         * @param {object} state 
         */
        setButtonState(buttonName, state) {
            this._controlButtons[buttonName] = {
                active: state.active ?? this._controlButtons[buttonName].active,
                skip: state.skip ?? this._controlButtons[buttonName].skip,
            };
            this._panelDomParts.buttons[buttonName].classList =
                state.active ? 'activate' : '';
        }

        /**
         * @param {string} buttonName
         * @returns {object} state
         */
        getButtonState(buttonName) {
            return this._controlButtons[buttonName];
        }

        /**
         * @param {string} partName 
         */
        clearPanelPart(partName) {
            this._panelDomParts[partName].innerHTML = '';
        }

        /**
         * @param {string} partName 
         * @param {HTMLElement} content 
         */
        fillPanelPart(partName, content) {
            this._panelDomParts[partName].append(content)
        }

        changeButtonContent(buttonName, content) {
            this._panelDomParts.buttons[buttonName].textContent = '';
            this._panelDomParts.buttons[buttonName].textContent = content;
        }

        changeButtonContentToDefault(buttonName) {
            this._panelDomParts.buttons[buttonName].textContent = '';
            this._panelDomParts.buttons[buttonName].textContent =
                this._defaultButtonContent[buttonName];
        }
    }
</script>

<script src="https://docs.opencv.org/4.5.2/opencv.js" async onload="main({})"></script>
</html>